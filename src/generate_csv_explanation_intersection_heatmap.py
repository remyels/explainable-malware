import pandas as pd
import pickle

# Compression factor denotes the width of the square of cells we'll be joining together
compression_factor = 3

# The malware for which we have the explanations are common across all experiments, so we populate those in order based on one of the experiments
sortedmalwarenames = []

df = pd.read_csv('trainLabels.csv')

available_feature_sets = ['saynotooverfittingsemimodel',  '2-grams']
available_models = ['rfc', 'mlr', '2layernn', 'xgboost']
available_explainers = ['shap', 'lime']

# Pick a random experiment to use to get the order of the malware by class
intersection_result = pickle.load(open("scratch/Results/{}/{}/{}/intersection_explanations.pickle".format(available_feature_sets[0], available_models[0], available_explainers[0]), "rb"))

intersection_keys = intersection_result.keys()

for row in df.itertuples():
    if row[1] in intersection_keys:
        sortedmalwarenames.append(row[1])

def generate_explanation_intersection_heatmap(feature_set, model, explainer):
    try:
        intersection_explanations = pickle.load(open("scratch/Results/{}/{}/{}/intersection_explanations.pickle".format(feature_set, model, explainer), "rb"))
    except FileNotFoundError:
        return
    f = open("scratch/Results/{}/{}/{}/malware_pairwise_explanations.csv".format(feature_set, model, explainer), "w")
    for malware_name in sortedmalwarenames:
        f.write(",{}".format(malware_name))
    f.write("\n")
    for i in range(len(sortedmalwarenames)):
        first_malware = sortedmalwarenames[i]
        f.write(first_malware)
        for j in range(len(sortedmalwarenames)):
            second_malware = sortedmalwarenames[j]
            len_inters_of_inters = len([x for x in intersection_explanations[first_malware] if x in intersection_explanations[second_malware]])
            f.write(",{}".format(len_inters_of_inters))
        f.write("\n")
    f.close()
    print("Done feature set: {} with model {} and explainer {}!".format(feature_set, model, explainer))

def generate_compressed_explanation_intersection_heatmap(feature_set, model, explainer, compression_factor):
    try:
        intersection_explanations = pickle.load(open("scratch/Results/{}/{}/{}/intersection_explanations.pickle".format(feature_set, model, explainer), "rb"))
    except FileNotFoundError:
        return
    f = open("scratch/Results/{}/{}/{}/malware_pairwise_explanations_compressed.csv".format(feature_set, model, explainer), "w")
    compressed_malware_names = []
    for i in range(0, len(sortedmalwarenames), compression_factor):
        compressed_malware_names.append("-".join([malwarename for malwarename in sortedmalwarenames[i:i+compression_factor]]))
    uncompressed_result = []
    malware_column = []
    for i in range(len(sortedmalwarenames)):
        uncompressed_row = []
        first_malware = sortedmalwarenames[i]
        malware_column.append(first_malware)
        for j in range(len(sortedmalwarenames)):
            second_malware = sortedmalwarenames[j]
            len_inters_of_inters = len([x for x in intersection_explanations[first_malware] if x in intersection_explanations[second_malware]])
            uncompressed_row.append(len_inters_of_inters)
        uncompressed_result.append(uncompressed_row)
    compressed_result = []
    for i in range(0, len(uncompressed_result), compression_factor):
        compressed_row = []
        for j in range(0, len(uncompressed_result[i]), compression_factor):
            compressed_row.append(compress_submatrix(uncompressed_result, i, j, i+compression_factor, j+compression_factor, len(uncompressed_result), len(uncompressed_result[i])))
        compressed_result.append(compressed_row)

    # Now, we start writing to the file 
    # First line
    for compressed_malware in compressed_malware_names:
        f.write(",{}".format(compressed_malware))
    f.write("\n")

    # Rest of the lines
    for i in range(len(compressed_malware_names)):
        f.write(compressed_malware_names[i])
        for val in compressed_result[i]:
            f.write(",{}".format(val))
        f.write("\n")
    f.close()
    print("Done feature set: {} with model {} and explainer {} (compressed)!".format(feature_set, model, explainer))

def generate_compressed_smooth_explanation_intersection_heatmap(feature_set, model, explainer, compression_factor):
    try:
        intersection_explanations = pickle.load(open("scratch/Results/{}/{}/{}/intersection_explanations.pickle".format(feature_set, model, explainer), "rb"))
    except FileNotFoundError:
        return
    f = open("scratch/Results/{}/{}/{}/malware_pairwise_explanations_compressed.csv".format(feature_set, model, explainer), "w")
    compressed_malware_names = []
    for i in range(0, len(sortedmalwarenames)-1+compression_factor):
        compressed_malware_names.append("-".join([malwarename for malwarename in sortedmalwarenames[i:i+compression_factor]]))
    uncompressed_result = []
    malware_column = []
    for i in range(len(sortedmalwarenames)):
        uncompressed_row = []
        first_malware = sortedmalwarenames[i]
        malware_column.append(first_malware)
        for j in range(len(sortedmalwarenames)):
            second_malware = sortedmalwarenames[j]
            len_inters_of_inters = len([x for x in intersection_explanations[first_malware] if x in intersection_explanations[second_malware]])
            uncompressed_row.append(len_inters_of_inters)
        uncompressed_result.append(uncompressed_row)
    compressed_result = []
    for i in range(0, len(uncompressed_result)-1+compression_factor):
        compressed_row = []
        for j in range(0, len(uncompressed_result[i])-1+compression_factor):
            compressed_row.append(compress_submatrix(uncompressed_result, i, j, i+compression_factor, j+compression_factor, len(uncompressed_result), len(uncompressed_result[i])))
        compressed_result.append(compressed_row)

    # Now, we start writing to the file
    # First line
    for compressed_malware in compressed_malware_names:
        f.write(",{}".format(compressed_malware))
    f.write("\n")

    # Rest of the lines
    for i in range(len(compressed_malware_names)):
        f.write(compressed_malware_names[i])
        for val in compressed_result[i]:
            f.write(",{}".format(val))
        f.write("\n")
    f.close()
    print("Done feature set: {} with model {} and explainer {} (compressed smoothly)!".format(feature_set, model, explainer))


def compress_submatrix(uncompressed_result, sx, sy, ex, ey, w, h):
    result = 0
    count = 0
    for row in range(sy, ey+1):
        for col in range(sx, ex+1):
            if col < w and row < h:
                count += 1
                result += uncompressed_result[row][col]
    return result / count

for feature_set in available_feature_sets:
    for model in available_models:
        for explainer in available_explainers:
            generate_explanation_intersection_heatmap(feature_set, model, explainer)
            generate_compressed_explanation_intersection_heatmap(feature_set, model, explainer, compression_factor)
